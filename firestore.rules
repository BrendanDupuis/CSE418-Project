rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function sep() { return "____"; }

    function isSignedIn() {
      return request.auth != null;
    }

    function isTwoFactorVerified() {
      return isSignedIn() && request.auth.token.twoFactorVerified == true;
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function isSafeId(id) {
      // Adjust regex if your UID format differs
      return id is string && id.matches('^[a-zA-Z0-9_-]+$');
    }

    function userExists(uid) {
      return exists(/databases/$(database)/documents/users/$(uid));
    }

    function bothUsersExist(u1, u2) {
      return userExists(u1) && userExists(u2);
    }

    // Lexical min/max to avoid sort()
    function minStr(a, b) { return a <= b ? a : b; }
    function maxStr(a, b) { return a <= b ? b : a; }

    function expectedChatId(u1, u2) {
      return minStr(u1, u2) + sep() + maxStr(u1, u2);
    }

    // Cache the chat doc read once
    function chatDoc(chatId) {
      return get(/databases/$(database)/documents/chat/$(chatId));
    }

    function chatExists(chatId) {
      return exists(/databases/$(database)/documents/chat/$(chatId));
    }

    function isChatParticipant(chatId) {
      return isSignedIn()
        && chatExists(chatId)
        && (
          request.auth.uid == chatDoc(chatId).data.user1 ||
          request.auth.uid == chatDoc(chatId).data.user2
        );
    }
    match /usernames/{name} {
        allow read: if true;
        allow create: if isSignedIn() && !exists(/databases/$(database)/documents/usernames/$(name));
        allow update, delete: if false;
    }
    match /users/{uid} {
      allow read: if isSignedIn() && isTwoFactorVerified();

      allow create: if isOwner(uid)
        && request.resource.data.keys().hasOnly(['username', 'email', 'createdAt'])
        && request.resource.data.username is string
        && request.resource.data.email is string
        && request.resource.data.email == request.auth.token.email
        && request.resource.data.createdAt is timestamp;

      allow update: if isOwner(uid) && isTwoFactorVerified()
        && request.resource.data.keys().hasOnly(['username', 'email', 'createdAt', 'deletedAt'])
        && request.resource.data.username is string
        && request.resource.data.email is string
        && request.resource.data.createdAt is timestamp
        && (request.resource.data.deletedAt == null || request.resource.data.deletedAt is timestamp);
      allow delete: if false;

      match /chats/{chatId} {
        allow read: if isOwner(uid) && isTwoFactorVerified();
        allow create: if isOwner(uid) && isTwoFactorVerified();
        allow update: if false;
        allow delete: if isOwner(uid) && isTwoFactorVerified();
      }
    }

    match /chat/{chatId} {
      // Only participants can read the chat document
      allow read: if isChatParticipant(chatId) && isTwoFactorVerified();
      
      // Allow querying chat documents for account deletion
      allow list: if false;

      // Only participants can create with canonical chatId and valid users
      allow create: if isSignedIn() && isTwoFactorVerified()
        && request.resource.data.keys().hasOnly(['user1', 'user2', 'createdAt'])
        && request.resource.data.user1 is string
        && request.resource.data.user2 is string
        && request.resource.data.user1 != request.resource.data.user2
        && isSafeId(request.resource.data.user1)
        && isSafeId(request.resource.data.user2)
        && bothUsersExist(request.resource.data.user1, request.resource.data.user2)
        // enforce canonical chatId = min(u1,u2) + "____" + max(u1,u2)
        && chatId == expectedChatId(request.resource.data.user1, request.resource.data.user2)
        // creator must be a participant
        && (request.auth.uid == request.resource.data.user1 || request.auth.uid == request.resource.data.user2)
        && request.resource.data.createdAt is timestamp;

      // chat documents are immutable
      allow update: if false;
      allow delete: if false;

      match /messages/{messageId} {
        allow read: if isChatParticipant(chatId) && isTwoFactorVerified();

        allow create: if isChatParticipant(chatId) && isTwoFactorVerified()
          && request.resource.data.keys().hasOnly(['senderEncryptedText', 'receiverEncryptedText', 'fromUserId', 'timestamp'])
          && request.resource.data.senderEncryptedText is string
          && request.resource.data.senderEncryptedText.size() > 0
          && request.resource.data.receiverEncryptedText is string
          && request.resource.data.receiverEncryptedText.size() > 0
          && request.resource.data.fromUserId is string
          && request.resource.data.timestamp is timestamp
          && request.auth.uid == request.resource.data.fromUserId;

        allow update: if false;

        allow delete: if isChatParticipant(chatId) && isTwoFactorVerified()
          && request.auth.uid == resource.data.fromUserId;
      }

      match /publicKeys/{userId} {
        allow read: if isChatParticipant(chatId) && isTwoFactorVerified();

        allow create: if isChatParticipant(chatId) && isTwoFactorVerified()
          && request.resource.data.keys().hasOnly(['userId', 'publicKey', 'createdAt', 'updatedAt'])
          && request.resource.data.userId is string
          && request.resource.data.userId == userId
          && request.resource.data.publicKey is map
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp
          && request.auth.uid == userId;

        allow update: if isChatParticipant(chatId) && isTwoFactorVerified()
          && request.resource.data.keys().hasOnly(['publicKey', 'updatedAt'])
          && request.resource.data.publicKey is map
          && request.resource.data.updatedAt is timestamp
          && request.auth.uid == userId;

        allow delete: if isChatParticipant(chatId)
          && request.auth.uid == userId;
      }

      match /privateKeys/{userId} {
        allow read: if isChatParticipant(chatId) && isTwoFactorVerified()
          && request.auth.uid == userId;

        allow create: if isChatParticipant(chatId) && isTwoFactorVerified()
          && request.resource.data.keys().hasOnly(['userId', 'encryptedPrivateKey', 'createdAt', 'updatedAt'])
          && request.resource.data.userId is string
          && request.resource.data.userId == userId
          && request.resource.data.encryptedPrivateKey is string
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp
          && request.auth.uid == userId;

        allow update: if isChatParticipant(chatId) && isTwoFactorVerified()
          && request.resource.data.keys().hasOnly(['encryptedPrivateKey', 'updatedAt'])
          && request.resource.data.encryptedPrivateKey is string
          && request.resource.data.updatedAt is timestamp
          && request.auth.uid == userId;

        allow delete: if isChatParticipant(chatId) && isTwoFactorVerified()
          && request.auth.uid == userId;
      }
    }

    match /verificationCodes/{userId} {
      allow read, write: if false;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}